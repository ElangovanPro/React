
const arr=[1,2,3,4,5];//2,4,6,8,10

// function double(arr)
// {
// let arr2=[];
// for(let i=0;i<arr.length;i++){
// arr2[i]=arr[i]*2;
// }
// return arr2;
// }
// console.log(double(arr));

function double(number){
  return number*2;
}

const double1=arr.map(e=>e*2);//anonyms arrow functions
// const result=arr.map(double);//map is higer order, double is calback
console.log(arr);
console.log(double1);





c++==> cpp
c=>.c
java=>.java
python=>.py



react=>js,jsx,ts,tsx 


react.createelement==> js object => render(html)

jsx is convention it merges the html and javascript.

The flow from JSX to rendered HTML in a React application involves several key steps:


JSX (JavaScript XML): Developers write UI components using JSX, which is a syntax extension for JavaScript allowing HTML-like syntax directly within JavaScript code. This makes the component structure more readable and intuitive.

Code

    const MyComponent = () => {
      return <h1>Hello, React!</h1>;
    };


Babel Transpilation:

 Browsers do not natively understand JSX. Therefore, a JavaScript compiler like Babel is used to transpile the JSX code into standard JavaScript that browsers can execute. During this step, Babel transforms JSX elements into React.createElement() calls.

JavaScript

    // Transpiled by Babel from the JSX above
    const MyComponent = () => {
      return React.createElement('h1', null, 'Hello, React!');
    };

React.createElement():

This function is the core of how React creates elements. It takes three main arguments: the type of element (e.g., 'div', 'h1', or a custom component), an object containing its props (attributes), and its children. It returns a plain JavaScript object representing the element in the React 
Virtual DOM.


React Virtual DOM:

React maintains a lightweight, in-memory representation of the actual DOM, known as the Virtual DOM. When React.createElement() is called, it creates elements within this Virtual DOM. This allows React to efficiently track changes to the UI.

Reconciliation and Rendering:

When a component's state or props change, React creates a new Virtual DOM tree. It then compares this new tree with the previous one (a process called reconciliation) to identify the minimal set of changes required to update the actual DOM. Finally, React applies these changes to the browser's real DOM, resulting in the rendered HTML visible to the user.


